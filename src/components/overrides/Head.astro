---
import Default from "@astrojs/starlight/components/Head.astro";
import { differenceInCalendarDays } from "date-fns";
import "tippy.js/dist/tippy.css";

import { getEntry } from "astro:content";

const DEFAULT_TITLE_DELIMITER = "|";
const NOINDEX_PRODUCTS = ["email-security"];
const CHATBOT_DEPRIORITIZE_PRODUCTS = ["firewall", "style-guide"];

const currentSection = Astro.url.pathname.split("/")[1].replaceAll(".", "");

const { entry, head, lastUpdated } = Astro.locals.starlightRoute;
const frontmatter = entry.data;

const metaTags = [] as Record<string, string>[];

const shouldNoIndex =
	NOINDEX_PRODUCTS.includes(currentSection) ||
	frontmatter.noindex ||
	frontmatter.external_link;

const shouldChatbotDeprioritize =
	CHATBOT_DEPRIORITIZE_PRODUCTS.includes(currentSection) ||
	frontmatter.sidebar.group?.hideIndex ||
	frontmatter.sidebar.hidden ||
	frontmatter.chatbot_deprioritize;

if (currentSection) {
	let product = await getEntry("products", currentSection);
	if (currentSection === "changelog") {
		const products = frontmatter.products;
		if (products) {
			product = await getEntry("products", products[0]);
		}
	}

	if (product) {
		let productMetaName = product.data.meta.title
			? product.data.meta.title
			: "Loproda Docs";

		if (currentSection === "changelog") {
			productMetaName = "Changelog";
		}

		const titleIdx = head.findIndex((x) => x.tag === "title");
		let title: string;

		const existingTitle = head[titleIdx].content
			? head[titleIdx].content?.split(` ${DEFAULT_TITLE_DELIMITER} `)[0]
			: frontmatter.title;

		title = `${existingTitle} Â· ${productMetaName}`;

		head[titleIdx] = {
			tag: "title",
			content: title,
		};

		metaTags.push({
			property: "og:title",
			content: title,
		});

		if (product.data.product.title) {
			["pcx_product", "algolia_product_filter"].map((name) => {
				metaTags.push({
					name,
					content: product.data.product.title,
				});
			});
		}

		if (product.data.product.group) {
			head.push({
				tag: "meta",
				attrs: {
					name: "pcx_content_group",
					content: product.data.product.group,
				},
			});
		}
	}
}

if (shouldNoIndex) {
	metaTags.push({
		name: "robots",
		content: "noindex",
	});
}

if (shouldChatbotDeprioritize) {
	head.push({
		tag: "meta",
		attrs: {
			name: "pcx_chatbot_deprioritize",
			content: true,
		},
	});
}

if (
	frontmatter.description &&
	head.findIndex(
		({ tag, attrs }) => tag === "meta" && attrs?.name === "description"
	) === -1
) {
	const existingOpenGraphTag = head.findIndex(
		({ tag, attrs }) => tag === "meta" && attrs?.property === "og:description"
	);

	if (existingOpenGraphTag !== -1) {
		head[existingOpenGraphTag].attrs!.content = frontmatter.description;
	}

	metaTags.push({
		name: "description",
		content: frontmatter.description as string,
	});
}

if (frontmatter.pcx_content_type) {
	["pcx_content_type", "algolia_content_type"].map((name) => {
		metaTags.push({
			name,
			content: frontmatter.pcx_content_type as string,
		});
	});
}

if (frontmatter.products) {
	metaTags.push({
		name: "pcx_additional_products",
		content: frontmatter.products.toString(),
	});
}

if (frontmatter.tags) {
	metaTags.push({
		name: "pcx_tags",
		content: frontmatter.tags.toString(),
	});
}

if (lastUpdated) {
	const daysBetween = differenceInCalendarDays(new Date(), lastUpdated);

	metaTags.push({
		name: "pcx_last_modified",
		content: daysBetween.toString(),
	});
}

if (frontmatter.updated) {
	const daysBetween = differenceInCalendarDays(new Date(), frontmatter.updated);

	metaTags.push({
		name: "pcx_last_reviewed",
		content: daysBetween.toString(),
	});
}

if (frontmatter.external_link) {
	metaTags.push({
		content: `0; url=${frontmatter.external_link}`,
		"http-equiv": "refresh",
	});
}

if (frontmatter.pcx_content_type === "changelog") {
	const href = new URL(entry.id.concat("/index.xml"), Astro.url.origin);

	head.push({
		tag: "link",
		attrs: {
			rel: "alternate",
			type: "application/rss+xml",
			href: href.toString(),
		},
	});
}

metaTags.map((attrs) => {
	head.push({
		tag: "meta",
		attrs,
	});
});

const headTitle = head.findIndex((t) => t.tag === "title");
if (headTitle !== -1) {
	if (head[headTitle].content?.endsWith("undefined")) {
		head[headTitle].content = head[headTitle].content.replace(
			"undefined",
			"Loproda Docs"
		);
	}
}
---

<script src="src/scripts/footnotes.ts"></script>
<script src="src/scripts/mermaid.ts"></script>
<Default><slot /></Default>
